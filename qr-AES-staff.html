<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ğŸ” JWTç…§åˆï¼ˆQRèª­ã¿å–ã‚Šï¼‹AESå¾©å·ï¼‰</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jsrsasign/10.5.24/jsrsasign-all-min.js"></script>
  <script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>
  <style>
    body { font-family: sans-serif; text-align: center; padding: 20px; }
    button { padding: 10px 20px; font-size: 16px; margin: 10px; cursor: pointer; }
    pre { background: #f9f9f9; padding: 10px; white-space: pre-wrap; text-align: left; width: 90%; margin: 10px auto; border-radius: 8px; border: 1px solid #ccc; }
    #reader { width: 320px; margin: 20px auto; }
    .match { color: green; font-weight: bold; }
    .mismatch { color: red; font-weight: bold; }
  </style>
</head>
<body>

  <h1>ğŸ” JWTèªè¨¼ï¼ˆAESå¾©å·ï¼‹QRèª­ã¿å–ã‚Šï¼‰</h1>

  <p>â‘¡ã§ç”Ÿæˆã•ã‚ŒãŸQRã‚³ãƒ¼ãƒ‰ã‚’èª­ã¿å–ã‚Šã€ç«¯æœ«ç•ªå·ã‚’ç…§åˆã—ã¾ã™ã€‚</p>

  <input id="event_nonce_input" placeholder="ä¼šå ´ä¹±æ•°ã‚’å…¥åŠ›"><br>
  
  <button onclick="startScan()">ğŸ“· QRã‚³ãƒ¼ãƒ‰ã‚’èª­ã¿å–ã‚‹</button>
  <div id="reader"></div>

  <h3>ğŸ“¦ JWTï¼ˆæ–‡å­—åˆ—ï¼‰</h3>
  <pre id="jwtDisplay"></pre>

  <h3>ğŸ“„ Payload</h3>
  <pre id="payloadDisplay"></pre>

  <h3>ğŸ” èªè¨¼çµæœ</h3>
  <p id="result"></p>

  <script>
    // AESéµï¼ˆâ‘ â‘¡ã¨åŒä¸€ã®å›ºå®šã‚­ãƒ¼ã‚’ä½¿ç”¨ï¼‰
    async function getAesKey() {
      const keyMaterial = new TextEncoder().encode("1234567890abcdef1234567890abcdef");
      return crypto.subtle.importKey(
        "raw",
        keyMaterial,
        { name: "AES-GCM", length: 256 },
        false,
        ["encrypt", "decrypt"]
      );
    }

    // åº—æš—å·å¾©å·å‡¦ç†
    async function decryptDeviceId(base64) {
      try {
        const key = await getAesKey();
        const data = Uint8Array.from(atob(base64), c => c.charCodeAt(0));
        const iv = data.slice(0, 12);
        const cipher = data.slice(12);
        const plain = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, cipher);
        return new TextDecoder().decode(plain);
      } catch (e) {
        console.error("åº—æš—å·å¾©å·ã‚¨ãƒ©ãƒ¼:", e);
        return null;
      }
    }

    //ä¼šå ´ä¹±æ•°æš—å·å¾©å·å‡¦ç†
    async function decryptWithNonce(base64, nonceKey) {
      try {
        const raw = Uint8Array.from(atob(base64), c => c.charCodeAt(0));
        const iv = raw.slice(0, 16);
        const cipher = raw.slice(16);
        const keyData = new TextEncoder().encode(nonceKey.padEnd(32).slice(0, 32));
        const key = await crypto.subtle.importKey(
          "raw",
          keyData,
          { name: "AES-CBC" },
          false,
          ["decrypt"]
        );

        const plainBuffer = await crypto.subtle.decrypt(
          { name: "AES-CBC", iv },
          key,
          cipher
        );

        return new TextDecoder().decode(plainBuffer);

      } catch (e) {
        console.error("ä¼šå ´ä¹±æ•°å¾©å·ã‚¨ãƒ©ãƒ¼:", e);
        return null;
      }
    } 
    
    // JWTãƒ‡ã‚³ãƒ¼ãƒ‰
    function decodePayload(jwt) {
      const parts = jwt.split(".");
      if (parts.length !== 3) throw new Error("JWTå½¢å¼ãŒä¸æ­£ã§ã™");
      const payloadB64 = parts[1].replace(/-/g, "+").replace(/_/g, "/");
      const padded = payloadB64.padEnd(payloadB64.length + (4 - payloadB64.length % 4) % 4, "=");
      const decoded = atob(padded);
      return JSON.parse(decoded);
    }

    // QRèª­ã¿å–ã‚Šé–‹å§‹
    function startScan() {
      const readerDiv = document.getElementById("reader");
      readerDiv.innerHTML = "";
      const html5QrCode = new Html5Qrcode("reader");

      html5QrCode.start(
        { facingMode: "environment" },
        { fps: 10, qrbox: 250 },
        async (decodedText) => {
          await html5QrCode.stop();
          document.getElementById("jwtDisplay").textContent = decodedText;

          try {
            const payload = decodePayload(decodedText);
            document.getElementById("payloadDisplay").textContent =
              JSON.stringify(payload, null, 2);

            const eventNonce = document.getElementById("event_nonce_input").value.trim();

           
            // æƒ…å ±ãŒè¶³ã‚Šãªã„å ´åˆ
             if (!eventNonce) {
              document.getElementById("result").innerHTML =
                "<span class='mismatch'>âš ï¸ ä¼šå ´ä¹±æ•°ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚</span>";
              return;
            }
            
            if (!payload.device_id_reencrypted || !payload.device_id) {
              document.getElementById("result").innerHTML =
                "<span class='mismatch'>âš ï¸ å¿…è¦ãªæƒ…å ±ï¼ˆdevice_id / device_id_encryptedï¼‰ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚</span>";
              return;
            }

             //1æ®µéšç›®ï¼šä¼šå ´ä¹±æ•°ã§å¾©å·(AES-CBC)
            const storeEncrypted = await decryptWithNonce(
              payload.device_id_reencrypted,
              eventNonce
            );

            if (!storeEncrypted) {
              document.getElementById("result").innerHTML =
                "<span class='mismatch'>âŒ ä¼šå ´ä¹±æ•°ãŒä¸æ­£ã§ã™ï¼ˆå¾©å·å¤±æ•—ï¼‰ã€‚</span>";
              return;
            }

            //2æ®µéšç›®ï¼šå›ºå®šéµã§ç«¯æœ«ç•ªå·ã‚’å¾©å·
            const decrypted = await decryptDeviceId(storeEncrypted);

            if (!decrypted) {
              document.getElementById("result").innerHTML =
                "<span class='mismatch'>âŒ AESå¾©å·ã«å¤±æ•—ã—ã¾ã—ãŸã€‚</span>";
              return;
            }

            // ä¸€è‡´åˆ¤å®š
            if (payload.device_id === decrypted) {
              document.getElementById("result").innerHTML =
                `<span class='match'>âœ… èªè¨¼æˆåŠŸï¼åŒä¸€ç«¯æœ«ã®QRã‚³ãƒ¼ãƒ‰ã§ã™ã€‚<br>å¾©å·çµæœï¼š${decrypted}</span>`;
            } else {
              document.getElementById("result").innerHTML =
                `<span class='mismatch'>âŒ èªè¨¼å¤±æ•—ï¼šç«¯æœ«ç•ªå·ãŒä¸€è‡´ã—ã¾ã›ã‚“ã€‚<br>å¾©å·çµæœï¼š${decrypted}</span>`;
            }

          } catch (e) {
            console.error("è§£æã‚¨ãƒ©ãƒ¼:", e);
            document.getElementById("result").innerHTML =
              "<span class='mismatch'>âŒ JWTã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸã€‚</span>";
          }

          // å†ã‚¹ã‚­ãƒ£ãƒ³ãƒœã‚¿ãƒ³
          const retryBtn = document.createElement("button");
          retryBtn.textContent = "ğŸ”„ ã‚‚ã†ä¸€åº¦ã‚¹ã‚­ãƒ£ãƒ³ã™ã‚‹";
          retryBtn.onclick = startScan;
          document.getElementById("reader").appendChild(retryBtn);
        },
        (error) => { /* ã‚¹ã‚­ãƒ£ãƒ³ä¸­ã®ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦– */ }
      );
    }
  </script>

</body>
</html>


